{% load static %}
<!DOCTYPE html>
<html>
<head>
	<title>Network Diagram</title>
	<style>
		.links line {
			stroke: #999;
			stroke-opacity: 0.6;
		}

		.nodes circle {
			stroke: black	;
			stroke-width: 0px;
		}
	</style>
</head>
<body>
	<!-- solução baseada em https://bl.ocks.org/puzzler10/4438752bb93f45dc5ad5214efaa12e4a -->
	<svg width="800" height="500"></svg>
	<script src="https://d3js.org/d3.v4.js"></script>
	<script type="text/javascript">
		var getUrl = window.location;
		var baseUrl = getUrl .protocol + "//" + getUrl.host;// + "/" + getUrl.pathname.split('/')[1];
		var static_url = baseUrl+'{{st_url}}'
		var svg = d3.select("svg"),
		width = +svg.attr("width"),
		height = +svg.attr("height");

		var radius = 15; 

		var data = {{dados|safe}};
		//var defs = svg.insert("svg:defs")
		//	.data(["end"]);


		//defs.enter().append("svg:path")
		//	.attr("d", "M0,-5L10,0L0,5");
		//console.log(data);
		//set up the simulation and add forces  
		var simulation = d3.forceSimulation()
							.nodes(data.nodes);
									
		var link_force =  d3.forceLink(data.links)
								.id(function(d) { return d.id; });            
				
		var charge_force = d3.forceManyBody()
			.strength(-100); 
			
		var center_force = d3.forceCenter(width / 2, height / 2);  
							
		simulation
			.force("charge_force", charge_force)
			.force("center_force", center_force)
			.force("links",link_force)
		;

		//add tick instructions: 
		simulation.on("tick", tickActions );

		//add encompassing group for the zoom 
		var g = svg.append("g")
			.attr("class", "everything");

		//draw lines for the links 
		var link = g.append("g")
			.attr("class", "links")
			.selectAll("line")
			.data(data.links)
			.enter().append("line")
			.attr("stroke-width", 2)
			//.style("stroke", linkColour);        

		//draw circles for the nodes 
		var node = g.append("g")
				.attr("class", "nodes") 
				.selectAll("circle")
				.data(data.nodes)
				.enter()/*
				.append("circle")
				.attr("r", radius)
				.attr("fill", nodeColor)/*;

		var img = node.*/.filter((d) => d.nodeType == 2).append("image")
		        .attr("xlink:href",  function(d) {  return static_url+'champion/'+d.championId+'.png'})
		        .attr("x", function(d) { return -25;})
		        .attr("y", function(d) { return -25;})
		        .attr("height", 50)
		        .attr("width", 50);
		//console.log(img)

		node.append('title')
				.text(function(d){
					return nodeName(d);
				});
		/*node.append("text")
			.attr("class", "nodetext")
			.attr("x", 20)
			.attr("y", 40)
			.attr("fill", '#333')
			.text(function(d) { return d.name; });*/
		
		
		//add drag capabilities  
		var drag_handler = d3.drag()
			.on("start", drag_start)
			.on("drag", drag_drag)
			.on("end", drag_end);	
			
		drag_handler(node);


		//add zoom capabilities 
		var zoom_handler = d3.zoom()
			.on("zoom", zoom_actions);

		zoom_handler(svg);  
		function nodeName(d){
			var name = d.name;
			if(d.nodeType==3)
				name+='\n'+d.value.toFixed(2)
			return name;

		}
		function nodeColor(d){
			if(d.nodeType==0)
				return "#000000"
			if(d.nodeType==1)
				return "#ff0000"
			if(d.nodeType==2)
				return "#00ff00"
			if(d.nodeType==3)
				return "#0000ff"
						
			return "#69b3a2"
		}
		//Drag functions 
		//d is the node 
		function drag_start(d) {
		if (!d3.event.active) simulation.alphaTarget(0.3).restart();
			d.fx = d.x;
			d.fy = d.y;
		}
		//make sure you can't drag the circle outside the box
		function drag_drag(d) {
			d.fx = d3.event.x;
			d.fy = d3.event.y;
		}

		function drag_end(d) {
			if (!d3.event.active) simulation.alphaTarget(0);
			d.fx = null;
			d.fy = null;
		}

		//Zoom functions 
		function zoom_actions(){
			g.attr("transform", d3.event.transform)
		}

		function tickActions() {
			//update circle positions each tick of the simulation 
			node
				/*.attr("cx", function(d) { if(d.nodeType!=2) return d.x; })
				.attr("cy", function(d) { if(d.nodeType!=2) return d.y; })*/
				.attr("transform", function(d) {
					/*d.x =  Math.max(0, Math.min(width - (50/2 || 16), d.x));
    				d.y =  Math.max(50, Math.min(height - (50/2 || 16), d.y));*/
    				if(d.nodeType==2)
		            return "translate(" + d.x + "," + d.y + ")";
		        });
				
			//update link positions 
			link
				.attr("x1", function(d) { return d.source.x; })
				.attr("y1", function(d) { return d.source.y; })
				.attr("x2", function(d) { return d.target.x; })
				.attr("y2", function(d) { return d.target.y; });
		}


	</script>

</body>
</html>