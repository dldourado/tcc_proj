{% load static %}
<!DOCTYPE html>
<html>
<head>
	<title>Network Diagram</title>
	<style>
		.links line {
			stroke: #999;
			stroke-opacity: 0.6;
		}

		.nodes circle {
			stroke: black;
		}
		ul{
			list-style: none;
		}
		ul li{
			display: inline;
			padding: 5px;
			border: solid 1px #333;
			border-radius: 25px;
		}
		ul li:first-child{
			border-color: transparent;
		}
	</style>
</head>
<body>
	<!-- solução baseada em https://bl.ocks.org/puzzler10/4438752bb93f45dc5ad5214efaa12e4a -->
	<ul>
		<li><label>Realçar: </label></li>
		{% for average in dados.averages %}
		<li><input type="checkbox" class="checkboxes" id="checkbox-{{average}}" name="{{average}}" onchange="tickActions()"><label>{{average}}</label></li>
		{% endfor %}
	</ul>
	<svg width="1200" height="600"></svg>
	<script src="https://d3js.org/d3.v4.js"></script>
	<script type="text/javascript">
		var getUrl = window.location;
		var baseUrl = getUrl .protocol + "//" + getUrl.host;// + "/" + getUrl.pathname.split('/')[1];
		var static_url = baseUrl+'{{st_url}}'
		var svg = d3.select("svg"),
		width = +svg.attr("width"),
		height = +svg.attr("height");

		var radius = 15; 

		var data = {{dados|safe}};
		//var defs = svg.insert("svg:defs")
		//	.data(["end"]);


		//defs.enter().append("svg:path")
		//	.attr("d", "M0,-5L10,0L0,5");
		//console.log(data);
		//set up the simulation and add forces  
		var simulation = d3.forceSimulation()
							.nodes(data.nodes);
									
		var link_force =  d3.forceLink(data.links)
								.id(function(d) { return d.id; });            
				
		var charge_force = d3.forceManyBody()
			.strength(-100); 
			
		var center_force = d3.forceCenter(width / 2, height / 2);  
							
		simulation
			.force("charge_force", charge_force)
			.force("center_force", center_force)
			.force("links",link_force)
		;

		//add tick instructions: 
		simulation.on("tick", tickActions );

		//add encompassing group for the zoom 
		var g = svg.append("g")
			.attr("class", "everything");

		//draw lines for the links 
		var link = g.append("g")
			.attr("class", "links")
			.selectAll("line")
			.data(data.links)
			.enter().append("line")
			.attr("stroke-width", 2)
			//.style("stroke", linkColour);        

		//draw circles for the nodes 
		var node = g.append("g")
				.attr("class", "nodes") 
				.selectAll("circle")
				.data(data.nodes)
				.enter().append("svg:g")
				.attr("class", "node")
				.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
				
		node.append("circle")
				.attr("r", radius)
				.attr("fill", nodeColor)
				.attr("stroke-width", nodeBorder);

		node.filter((d) => d.nodeType == 0).append("image")
		        .attr("xlink:href",  function(d) {  return static_url+'img/logo_lol.png'})
		        .attr("x", function(d) { return -63.5;})
		        .attr("y", function(d) { return -25;})
		        .attr("height", 50)
		        .attr("width", 127);

		node.filter((d) => d.nodeType == 1).append("image")
		        .attr("xlink:href",  function(d) {  return static_url+'img/'+d.name+'.png'})
		        .attr("x", function(d) { return -25;})
		        .attr("y", function(d) { return -25;})
		        .attr("height", 50)
		        .attr("width", 50);

		node.filter((d) => d.nodeType == 2).append("image")
		        .attr("xlink:href",  function(d) {  return static_url+'champion/'+d.championId+'.png'})
		        .attr("x", function(d) { return -25;})
		        .attr("y", function(d) { return -25;})
		        .attr("height", 50)
		        .attr("width", 50);
		//console.log(img)

		node.append('title')
				.text(function(d){
					return nodeName(d);
				});

		node.filter((d) => d.nodeType == 2).append("text")
			.attr("class", "nodetext")
			.attr("x", -25)
			.attr("y", 40)
			.attr("fill", '#333')
			.text(function(d) { return d.name; });

		node.filter((d) => d.nodeType == 3).append("text")
			.attr("class", "nodetext")
			.attr("x", -10)
			.attr("y", 5)
			.attr("fill", '#333')
			.attr("font-size",'10px')
			.text(function(d) { return smallNumbers(d.value); });
		
		
		//add drag capabilities  
		var drag_handler = d3.drag()
			.on("start", drag_start)
			.on("drag", drag_drag)
			.on("end", drag_end);	
			
		drag_handler(node);


		//add zoom capabilities 
		var zoom_handler = d3.zoom()
			.on("zoom", zoom_actions);

		zoom_handler(svg); 
		function smallNumbers(value){
			if(value>1000000)
				return String((value/1000000).toFixed(0)+'M');
			if(value>1000)
				return String((value/1000).toFixed(0)+'K');
			if(value>100)
				return value.toFixed(1);
			return value.toFixed(2);
		}
		function nodeSize(d){
			if(d.name in data.averages){
				if(document.getElementById('checkbox-'+d.name).checked){
					return 30;
				}
			}
			return 15;
		} 
		function nodeLabelSize(d){
			if(d.name in data.averages){
				if(document.getElementById('checkbox-'+d.name).checked){
					return 20;
				}
			}
			return 10;
		} 
		function coverAll(d){
			if(d.name in data.averages){
				if(document.getElementById('checkbox-'+d.name).checked){
					return true;
				}
			}
			return false;
		} 
		function nodeName(d){
			var name = d.name;
			if(d.nodeType==3)
				name+='\n'+d.value.toFixed(2)
			return name;

		}
		function nodeBorder(d){
			if(d.nodeType==3)
				return '1px';
			return '0px';

		}
		function nodeColor(d){
			if(d.nodeType==3){
				var neg = 1;
				if(d.value>data.averages[d.name]){
					neg = 1-Math.min(1,((d.value/data.averages[d.name])-1));
					//console.log(d.value,data.averages[d.name],neg);
					return 'rgb(255,'+String(neg*255)+','+String(neg*255)+')';
				}
				else if(d.value<data.averages[d.name]){
					neg = d.value/data.averages[d.name];
					return 'rgb('+String(neg*255)+','+String(neg*255)+',255)';
				}
				return "#ffffff"
			}
						
			return "transparent"
		}
		//Drag functions 
		//d is the node 
		function drag_start(d) {
		if (!d3.event.active) simulation.alphaTarget(0.3).restart();
			d.fx = d.x;
			d.fy = d.y;
		}
		//make sure you can't drag the circle outside the box
		function drag_drag(d) {
			d.fx = d3.event.x;
			d.fy = d3.event.y;
		}

		function drag_end(d) {
			if (!d3.event.active) simulation.alphaTarget(0);
			d.fx = null;
			d.fy = null;
		}

		//Zoom functions 
		function zoom_actions(){
			g.attr("transform", d3.event.transform)
		}

		function tickActions() {
			//update circle positions each tick of the simulation 
			node
				/*.attr("cx", function(d) { if(d.nodeType!=2) return d.x; })
				.attr("cy", function(d) { if(d.nodeType!=2) return d.y; })*/
				
				.attr("transform", function(d) {
					/*d.x =  Math.max(0, Math.min(width - (50/2 || 16), d.x));
    				d.y =  Math.max(50, Math.min(height - (50/2 || 16), d.y));
    				if(d.nodeType==2)*/
		            return "translate(" + d.x + "," + d.y + ")";
		        })
				.each(function(d){
					if (coverAll(d)){
						d3.select(this).raise();
					}
				})
		        .select('circle')
			        .attr('r',function(d){
						return nodeSize(d);
					});
				
			//update link positions 
			link
				.attr("x1", function(d) { return d.source.x; })
				.attr("y1", function(d) { return d.source.y; })
				.attr("x2", function(d) { return d.target.x; })
				.attr("y2", function(d) { return d.target.y; });
		}


	</script>

</body>
</html>