{% load static %}
<!DOCTYPE html>
<html>
<head>
	<title>Network Diagram</title>
	<style>
		.links line {
			stroke: #999;
			stroke-opacity: 0.6;
		}

		.nodes circle {
			stroke: black;
		}
		.invisible {
			display: none;
		}
		ul{
			list-style: none;
		}
		ul.avs > li{
			display: inline;
			padding: 5px;
			border: solid 1px #333;
			border-radius: 25px;
		}
		ul.avs > li:first-child{
			border-color: transparent;
		}
		.color-viewer{
			width: 10px;
			height: 10px;
			border: 1px solid black;
		}
		.colorPicker{
			max-width: 100px;
		}
		.content-inline{
			display: inline-flex;
		}
		.info{
			float: right;
		}
		.info span{
			border: 1px solid;
			border-radius: 50%;
			padding: 0 6.5px;
			margin-right: 5px;
			background-color: cyan;
			font-style: italic;
			font-weight: bolder;
		}
		.more-info{
			display: none;
			position: fixed;
			left: 25%;
			width: 50%;
			top: 5%;
			background-color: white;
			padding: 15px;
			border: solid 1px #333;
			border-radius: 25px;
		}
		.more-info p, .more-info li{
			font-size: 0.8em;
			text-align: justify;
		}
		.info:hover .more-info{
			display: block;
		}
		*{
			transition: 0.5s opacity linear;
		}
	</style>
</head>
<body>
	<!-- solução baseada em https://bl.ocks.org/puzzler10/4438752bb93f45dc5ad5214efaa12e4a -->
	<ul class="avs">
		<li><label>Realçar: </label></li>
		{% for average in dados.averages %}
		<li><input type="checkbox" class="average-checkboxes" id="checkbox-{{average}}" name="{{average}}" onchange="hideElements()"><label>{{average}}</label></li>
		{% endfor %}
		<li class="info"> <span>i</span>Mais informações
			<div class="more-info">
				<h4>A visualização</h4>
				<p>Esta visualização mostra os campeões do jogo League of Legends(raiz da arvore) organizados por grupos de suas classes(ícones dourados). Em cada campeão um conjunto de atributos estão ligados e mostram o valor médio daquele atributo para o personagem em todas as partidas da base de dados</p>
				<p>O seguinte conjunto de interações podem ser realizadas</p>
				<ol>
					<li>É possivel movimentar a visualização arrastando com o clique do mouse sobre a area dela</li>
					<li>É possivel dar zoom com o scroll do mouse(pinch em notebooks)</li>
					<li>Arrastar qualquer nó, trazendo o grupo mais próximo consigo</li>
					<li>Selecionar um ou mais atributos nos checkboxes superiores, removendo os não selecionados e aumentando o raio dos selecionados</li>
					<li>Selecionar um grupo de cores à direita</li>
				</ol>
				<h4>Como Visualizar: 1 grupo de cores</h4>
				<p>Por padrão até um grupo de cores pode ser selecionado, caso nenhum grupo for selecionado, um tom de vermelho será utilizado</p>
				<p>Os atributos dos campeões terão suas cores modificadas respeitando o critério da normalização, ou seja, os atributos com valores mais proximos do mínimo serão representados pelas cores mais a esquerda e os mais próximos do máximo, a direita(caso nenhum grupo de cores tenha sido selecionado, as cores se aproximam do branco e vermelho respectivamente). </p>
				<h4>Como Visualizar: 2 grupo de cores</h4>
				<p>Ao marcar a opção de utilizar dois grupos de cores os atributos serão colorizados baseando-se num calculo a partir da média geral daquele atributo entre todos os campeões, caso nenhum grupo for selecionado, tons de vermelho será utilizado para valores maiores que a média, e um tons de azul para valores abaixo.</p>
				<p>Ao selecionar grupos de cores nas duas colunas, as cores mais a direita do grupo "acima" representarão os valores maiores acima da média e as cores mais a direita do grupo "abaixo" os menores valores abaixo da média. As cores mais a esquerda dos grupos, representam os valores mais próximos da média</p>
			</div>
		</li>
	</ul>
	<div class="content-inline">
		<svg width="900" height="600"></svg>
		<ul id="colorPickerPositive" class="colorPicker"><li id="columnTitleAcima" style="opacity: 0;"><strong>Acima</strong></li></ul>
		<ul id="colorPickerNegative" class="colorPicker" style="opacity: 0;"><li><strong>Abaixo</strong></li></ul>
	</div>
	<div style="float:right;"><input id="duasCores" type="checkbox" name="qtdCor" onclick="useColor(this);">Usar duas cores?</div>
	<script src="https://d3js.org/d3.v4.js"></script>
	<script type="text/javascript">
		var cores = [
		//multi-hue
			['#edf8fb','#b2e2e2','#66c2a4','#2ca25f','#006d2c'],
			['#edf8fb','#b3cde3','#8c96c6','#8856a7','#810f7c'],
			['#f0f9e8','#bae4bc','#7bccc4','#43a2ca','#0868ac'],
			['#fef0d9','#fdcc8a','#fc8d59','#e34a33','#b30000'],
			['#f1eef6','#bdc9e1','#74a9cf','#2b8cbe','#045a8d'],
			['#f6eff7','#bdc9e1','#67a9cf','#1c9099','#016c59'],
			['#f1eef6','#d7b5d8','#df65b0','#dd1c77','#980043'],
			['#feebe2','#fbb4b9','#f768a1','#c51b8a','#7a0177'],
			['#ffffcc','#c2e699','#78c679','#31a354','#006837'],
			['#ffffcc','#a1dab4','#41b6c4','#2c7fb8','#253494'],
			['#ffffd4','#fed98e','#fe9929','#d95f0e','#993404'],
			['#ffffb2','#fecc5c','#fd8d3c','#f03b20','#bd0026'],
		//single-hue
			['#eff3ff','#bdd7e7','#6baed6','#3182bd','#08519c'],
			['#edf8e9','#bae4b3','#74c476','#31a354','#006d2c'],
			['#f7f7f7','#cccccc','#969696','#636363','#252525'],
			['#feedde','#fdbe85','#fd8d3c','#e6550d','#a63603'],
			['#f2f0f7','#cbc9e2','#9e9ac8','#756bb1','#54278f'],
			['#fee5d9','#fcae91','#fb6a4a','#de2d26','#a50f15']
		]
		var positive = document.getElementById('colorPickerPositive')
		var negative = document.getElementById('colorPickerNegative')
		var positiveStr = ''
		var negativeStr = ''
		for(var i=0;i<cores.length;i++){
			positiveStr+='<li class="content-inline"><input type="checkbox" class="positive-color-checkboxes" id="positiveCor-'+i+'"/>'
			negativeStr+='<li class="content-inline"><input type="checkbox" class="negative-color-checkboxes" id="negativeCor-'+i+'"/>'
			for(var j=0;j<cores[i].length;j++){
				positiveStr+='<div class="color-viewer" style="background-color: '+cores[i][j]+';"></div>'
				negativeStr+='<div class="color-viewer" style="background-color: '+cores[i][j]+';"></div>'
			}
			positiveStr+='</li>'
			negativeStr+='</li>'
		}
		positive.innerHTML+=positiveStr
		negative.innerHTML+=negativeStr

		var positives = document.getElementsByClassName('positive-color-checkboxes')
		var negatives = document.getElementsByClassName('negative-color-checkboxes')

		var positiveIndex = -1
		var negativeIndex = -1
		function changeState(caixa){
			var spl = caixa.id.split('-')
			if(spl[0]=="positiveCor"){
				negatives[parseInt(spl[1])].disabled = caixa.checked
				for(var j = 0;j<positives.length; j++){
					if(j!=parseInt(spl[1])&&positives[j].checked){
						positives[j].checked=false;
						negatives[j].disabled=false;
					}
				}

				if(caixa.checked){
					positiveIndex = parseInt(spl[1])
				}
				else{
					positiveIndex = -1
				}
			}
			else{
				positives[parseInt(spl[1])].disabled = caixa.checked
				for(var j = 0;j<negatives.length; j++){
					if(j!=parseInt(spl[1])&&negatives[j].checked){
						negatives[j].checked=false;
						positives[j].disabled=false;
					}
				}

				if(caixa.checked){
					negativeIndex = parseInt(spl[1])
				}
				else{
					negativeIndex = -1
				}
			}
			node
		        .select('circle')
			        .attr('fill',function(d){
						return nodeColor(d);
					});
		}
		function useColor(picker){
			if(picker.checked){
				document.getElementById('colorPickerNegative').style.opacity = '1';
				document.getElementById('columnTitleAcima').style.opacity = '1';
			}
			else{
				document.getElementById('colorPickerNegative').style.opacity = '0';
				document.getElementById('columnTitleAcima').style.opacity = '0';
			}
			node
		        .select('circle')
			        .attr('fill',function(d){
						return nodeColor(d);
					});			
		}

		for (var i = 0; i < positives.length; i++) {
			positives[i].addEventListener('change', (event) => {
				changeState(event.target)
			})
		}

		for (var i = 0; i < negatives.length; i++) {
			negatives[i].addEventListener('change', (event) => {
				changeState(event.target)
			})
		}

		var getUrl = window.location;
		var baseUrl = getUrl .protocol + "//" + getUrl.host;// + "/" + getUrl.pathname.split('/')[1];
		var static_url = baseUrl+'{{st_url}}'
		var svg = d3.select("svg"),
		width = +svg.attr("width"),
		height = +svg.attr("height");

		var radius = 15; 

		var data = {{dados|safe}};
		var menores_valores = {}
		var maiores_valores = {}
		for(var k in data.averages){
			menores_valores[k]=data.averages[k];
			maiores_valores[k]=data.averages[k];

		}
		for(var vals = 0; vals<data.nodes.length; vals++){
			if(data.nodes[vals].name in menores_valores){
				if(menores_valores[data.nodes[vals].name]>data.nodes[vals].value && /*retirar ao pegar mais dados*/data.nodes[vals].value!=0/*retirar ao pegar mais dados*/){
					menores_valores[data.nodes[vals].name]=data.nodes[vals].value;
				}
				else if(maiores_valores[data.nodes[vals].name]<data.nodes[vals].value){
					maiores_valores[data.nodes[vals].name]=data.nodes[vals].value;
				}
			}
		}
		//var defs = svg.insert("svg:defs")
		//	.data(["end"]);


		//defs.enter().append("svg:path")
		//	.attr("d", "M0,-5L10,0L0,5");
		//console.log(data);
		//set up the simulation and add forces  
		var simulation = d3.forceSimulation()
							.nodes(data.nodes);
									
		var link_force =  d3.forceLink(data.links)
								.id(function(d) { return d.id; });            
				
		var charge_force = d3.forceManyBody()
			.strength(-100); 
			
		var center_force = d3.forceCenter(width / 2, height / 2);  
							
		simulation
			.force("charge_force", charge_force)
			.force("center_force", center_force)
			.force("links",link_force)
		;

		//add tick instructions: 
		simulation.on("tick", tickActions );

		//add encompassing group for the zoom 
		var g = svg.append("g")
			.attr("class", "everything");

		//draw lines for the links 
		var link = g.append("g")
			.attr("class", "links")
			.selectAll("line")
			.data(data.links)
			.enter().append("line")
			.attr("stroke-width", 2)
			//.style("stroke", linkColour);        

		//draw circles for the nodes 
		var node = g.append("g")
				.attr("class", "nodes") 
				.selectAll("circle")
				.data(data.nodes)
				.enter().append("svg:g")
				.attr("class", "node visible")
				//.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
				
		node.append("circle")
				.attr("r", radius)
				.attr("fill", nodeColor)
				.attr("stroke-width", nodeBorder);

		node.filter((d) => d.nodeType == 0).append("image")
		        .attr("xlink:href",  function(d) {  return static_url+'img/logo_lol.png'})
		        .attr("x", function(d) { return -63.5;})
		        .attr("y", function(d) { return -25;})
		        .attr("height", 50)
		        .attr("width", 127);

		node.filter((d) => d.nodeType == 1).append("image")
		        .attr("xlink:href",  function(d) {  return static_url+'img/'+d.name+'.png'})
		        .attr("x", function(d) { return -25;})
		        .attr("y", function(d) { return -25;})
		        .attr("height", 50)
		        .attr("width", 50);

		node.filter((d) => d.nodeType == 2).append("image")
		        .attr("xlink:href",  function(d) {  return static_url+'champion/'+d.championId+'.png'})
		        .attr("x", function(d) { return -25;})
		        .attr("y", function(d) { return -25;})
		        .attr("height", 50)
		        .attr("width", 50);
		//console.log(img)

		node.append('title')
				.text(function(d){
					return nodeName(d);
				});

		node.filter((d) => d.nodeType == 2).append("text")
			.attr("class", "nodetext")
			.attr("x", -25)
			.attr("y", 40)
			.attr("fill", '#333')
			.text(function(d) { return d.name; });

		node.filter((d) => d.nodeType == 3).append("text")
			.attr("class", "nodetext")
			.attr("x", -10)
			.attr("y", 5)
			.attr("fill", '#333')
			.attr("font-size",'10px')
			.text(function(d) { return smallNumbers(d.value); });
		
		
		//add drag capabilities  
		var drag_handler = d3.drag()
			.on("start", drag_start)
			.on("drag", drag_drag)
			.on("end", drag_end);	
			
		drag_handler(node);


		//add zoom capabilities 
		var zoom_handler = d3.zoom()
			.on("zoom", zoom_actions);

		zoom_handler(svg); 
		function smallNumbers(value){
			if(value>1000000)
				return String((value/1000000).toFixed(0)+'M');
			if(value>1000)
				return String((value/1000).toFixed(0)+'K');
			if(value>100)
				return value.toFixed(1);
			return value.toFixed(2);
		}
		function nodeTransparency(d){
			if(document.querySelectorAll('.average-checkboxes:checked').length==0){
				return 1.0;
			}
			if(d.name in data.averages){
				if(document.getElementById('checkbox-'+d.name).checked){
					return 1.0;
				}
				else{
					return 0.0;
				}
			}
			return 1.0;
		} 
		function nodeSize(d){
			if(d.name in data.averages){
				if(document.getElementById('checkbox-'+d.name).checked){
					return 30;
				}
			}
			return 15;
		} 
		function nodeLabelSize(d){
			if(d.name in data.averages){
				if(document.getElementById('checkbox-'+d.name).checked){
					return 20;
				}
			}
			return 10;
		} 
		function coverAll(d){
			if(d.name in data.averages){
				if(document.getElementById('checkbox-'+d.name).checked){
					return true;
				}
			}
			return false;
		} 
		function nodeName(d){
			var name = d.name;
			if(d.nodeType==3)
				name+='\n'+d.value.toFixed(2)
			return name;

		}
		function nodeBorder(d){
			if(d.nodeType==3)
				return '1px';
			return '0px';

		}
		function calcRange(valor, media){
			var v = 0.0
			if(valor>media){
				v = Math.min(1,((valor/media)-1))
			}
			else{
				v = 1-(valor/media)
			}
			if(v>0.8){
				return 4
			}
			if(v>0.6){
				return 3
			}
			if(v>0.4){
				return 2
			}
			if(v>0.2){
				return 1
			}
			if(v>0.0){
				return 0
			}
			return 0
		}
		function calcRangeSingleColor(valor, media){
			var v = (valor/media)
			if(v>0.8){
				return 4
			}
			if(v>0.6){
				return 3
			}
			if(v>0.4){
				return 2
			}
			if(v>0.2){
				return 1
			}
			if(v>0.0){
				return 0
			}
			return 0
		}
		function nodeColor(d){
			if(d.nodeType==3){
				var neg = 1;
				if(!document.getElementById('duasCores').checked){//trocar condição
					if(positiveIndex!=-1){
						return cores[positiveIndex][calcRangeSingleColor(d.value - menores_valores[d.name],maiores_valores[d.name] - menores_valores[d.name])]
					}
					neg = 1-((d.value - menores_valores[d.name])/(maiores_valores[d.name] - menores_valores[d.name]))
					return 'rgb(255,'+String(neg*255)+','+String(neg*255)+')';
				}


				if(d.value>data.averages[d.name]){
					if(positiveIndex!=-1){
						return cores[positiveIndex][calcRange(d.value,data.averages[d.name])]
					}
					neg = 1-Math.min(1,((d.value/data.averages[d.name])-1));
					return 'rgb(255,'+String(neg*255)+','+String(neg*255)+')';
				}
				else if(d.value<data.averages[d.name]){
					if(negativeIndex!=-1){
						return cores[negativeIndex][calcRange(d.value,data.averages[d.name])]
					}
					neg = d.value/data.averages[d.name];
					return 'rgb('+String(neg*255)+','+String(neg*255)+',255)';
				}
				return "#ffffff"
			}
						
			return "transparent"
		}
		//Drag functions 
		//d is the node 
		function drag_start(d) {
		if (!d3.event.active) simulation.alphaTarget(0.3).restart();
			d.fx = d.x;
			d.fy = d.y;
		}
		//make sure you can't drag the circle outside the box
		function drag_drag(d) {
			d.fx = d3.event.x;
			d.fy = d3.event.y;
		}

		function drag_end(d) {
			if (!d3.event.active) simulation.alphaTarget(0);
			d.fx = null;
			d.fy = null;
		}

		//Zoom functions 
		function zoom_actions(){
			g.attr("transform", d3.event.transform)
		}

		function hideElements(){
			node
				.each(function(d){
					if(nodeTransparency(d)==1.0){
						d.visible = true
						d3.select(this).attr('opacity',1)
						link.each(function(l){
							if(l.source==d||l.target==d)
								d3.select(this).attr('opacity',1)
						})
					}
					else{
						d.visible=false
						d3.select(this).attr('opacity',0)
						link.each(function(l){
							if(l.source==d||l.target==d)
								d3.select(this).attr('opacity',0)
						})
					}
				})
		    tickActions();
		}
		function tickActions() {
			//update circle positions each tick of the simulation 
			node
				/*.attr("cx", function(d) { if(d.nodeType!=2) return d.x; })
				.attr("cy", function(d) { if(d.nodeType!=2) return d.y; })*/
				.filter(
					(d) => 
						(d.nodeType != 3) ||
						(d.nodeType == 3 && !('visible' in d) ) ||
						('visible' in d && d.visible==true)
				)
				.attr("transform", function(d) {
					/*d.x =  Math.max(0, Math.min(width - (50/2 || 16), d.x));
    				d.y =  Math.max(50, Math.min(height - (50/2 || 16), d.y));
    				if(d.nodeType==2)*/
    				//if(d.nodeType==3 && d.classList.contains("visible"))
		            return "translate(" + d.x + "," + d.y + ")";
		        })
				.each(function(d){
					if (coverAll(d)){
						d3.select(this).raise();
					}
				})
		        .select('circle')
		        	/*.attr('opacity',function(d){
		        		if(d.nodeType==3) return nodeTransparency(d);
		        		else return 1.0;
		        	})*/
			        .attr('r',function(d){
						return nodeSize(d);
					});
				
			//update link positions 
			link
				.attr("x1", function(d) { return d.source.x; })
				.attr("y1", function(d) { return d.source.y; })
				.attr("x2", function(d) { return d.target.x; })
				.attr("y2", function(d) { return d.target.y; });
		}


	</script>

</body>
</html>